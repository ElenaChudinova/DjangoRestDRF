# DjangoRestDRF + Docer
Задание 1
Создайте новый Django-проект, подключите DRF в настройках проекта.
Задание 2
Создайте следующие модели:
Пользователь:
все поля от обычного пользователя, но авторизацию заменить на email;
телефон;
город;
аватарка.
Модель пользователя разместите в приложении users
Курс:
название,
превью (картинка),
описание.
Урок:
название,
описание,
превью (картинка),
ссылка на видео.
Урок и курс - это связанные между собой сущности. Уроки складываются в курс, в одном курсе может быть много уроков. Реализуйте связь между ними.
Модель курса и урока разместите в отдельном приложении. Название для приложения выбирайте такое, чтобы оно описывало то, с какими сущностями приложение работает. Например, lms или materials - отличные варианты.
Задание 3
Опишите CRUD для моделей курса и урока. Для реализации CRUD для курса используйте Viewsets, а для урока - Generic-классы.
Для работы контроллеров опишите простейшие сериализаторы.
При реализации CRUD для уроков реализуйте все необходимые операции (получение списка, получение одной сущности, создание, изменение и удаление).
Для работы контроллеров опишите простейшие сериализаторы.
Работу каждого эндпоинта необходимо проверять с помощью Postman.
Также на данном этапе работы мы не заботимся о безопасности и не закрываем от редактирования объекты и модели даже самой простой авторизацией.

Продолжайте работу в проекте предыдущего домашнего задания
Задание 1
Для модели курса добавьте в сериализатор поле вывода количества уроков. Поле реализуйте с помощью 
SerializerMethodField()
Задание 2
Добавьте новую модель в приложение users:
Платежи
пользователь,
дата оплаты,
оплаченный курс или урок,
сумма оплаты,
способ оплаты: наличные или перевод на счет.
Поля 
пользователь
, 
оплаченный курс
 и 
отдельно оплаченный урок
 должны быть ссылками на соответствующие модели.
Запишите в таблицу, соответствующую этой модели данные через инструмент фикстур или кастомную команду.
Если вы забыли как работать с фикстурами или кастомной командой - можете вернуться к уроку 23 Работа с ORM в Django чтобы вспомнить материал.
Задание 3
Для сериализатора для модели курса реализуйте поле вывода уроков. Вывод реализуйте с помощью сериализатора для связанной модели.
Один сериализатор должен выдавать и количество уроков курса и информацию по всем урокам курса одновременно.
Задание 4
Настроить фильтрацию для эндпоинта вывода списка платежей с возможностями:
менять порядок сортировки по дате оплаты,
фильтровать по курсу или уроку,
фильтровать по способу оплаты.

Задание 1
Для сохранения уроков и курсов реализуйте дополнительную проверку на отсутствие в материалах ссылок на сторонние ресурсы, кроме youtube.com.
То есть ссылки на видео можно прикреплять в материалы, а ссылки на сторонние образовательные платформы или личные сайты — нельзя.
Создайте отдельный файл 
validators.py
, реализуйте валидатор, проверяющий ссылку, которую пользователь хочет записать в поле урока с помощью класса или функции.
Интегрируйте валидатор в сериализатор.
Если вы используете функцию-валидатор — указанием валидаторов для поля сериализатора 
validators=[ваш_валидатор]
.
Если вы используете класс-валидатор — указанием валидаторов в 
class Meta
:
validators = [ваш_валидатор(field='поле_которое_валидируем')]
.
Задание 2
Добавьте модель подписки на обновления курса для пользователя.
Модель подписки должна содержать следующие поля: «пользователь» (
FK
 на модель пользователя), «курс» (
FK
 на модель курса). Можете дополнительно расширить модель при необходимости.
Вам необходимо реализовать эндпоинт для установки подписки пользователя и на удаление подписки у пользователя.
 
Подсказка
 
При этом при выборке данных по курсу пользователю необходимо присылать признак подписки текущего пользователя на курс. То есть давать информацию, подписан пользователь на обновления курса или нет.
 
Подсказка
 
Задание 3
Реализуйте пагинацию для вывода всех уроков и курсов.
Пагинацию реализуйте в отдельном файле 
paginators.py
. Можно реализовать один или несколько классов пагинатора. Укажите параметры 
page_size
,
page_size_query_param
, 
max_page_size
 для класса
PageNumberPagination
. Количество элементов на странице выберите самостоятельно. Интегрируйте пагинатор в контроллеры, используя параметр
pagination_class
.
Задание 4
Напишите тесты, которые будут проверять корректность работы CRUD уроков и функционал работы подписки на обновления курса.
В тестах используйте метод 
setUp
 для заполнения базы данных тестовыми данными. Обработайте возможные варианты взаимодействия с контроллерами пользователей с разными правами доступа. Для аутентификации пользователей используйте 
self.client.force_authenticate()
. Документацию к этому методу можно найти тут.
Сохраните результат проверки покрытия тестами.

Задание
Опишите файл 
docker-compose
 для запуска всех частей проекта единой командой.

 Чтобы убедиться, что все сервисы в Docker запущены, используйте команду docker ps. Она отображает список всех активных контейнеров, включая их ID, образ, команду, статус, порты и имена. Если вы хотите увидеть также остановленные контейнеры, используйте docker ps -a. 
Подробности:
1. Проверка статуса контейнеров:
docker ps: Показывает список запущенных контейнеров. Это основной инструмент для мониторинга состояния контейнеров. 
docker ps -a: Показывает все контейнеры, включая остановленные, что полезно для выявления проблем. 
docker inspect <container_id_or_name>: Предоставляет подробную информацию о конкретном контейнере, включая его настройки, порты и т.д. 
2. Проверка логов:
docker logs <container_id_or_name>: Отображает логи контейнера, что может помочь в отладке и поиске проблем. 
docker logs --timestamps <container_id_or_name>: Добавляет временные метки к логам, что облегчает анализ. 
3. Проверка состояния сервисов в Docker Compose (если используется):
docker-compose config: Проверяет синтаксис файла docker-compose.yml. 
docker-compose config --resolve-image-digests: Проверяет замену переменных окружения в docker-compose.yml. 
docker-compose config --services: Показывает список сервисов, определенных в docker-compose.yml. 
4. Определение процессов внутри контейнера:
docker exec -it <container_id_or_name> bash: Доступ к оболочке контейнера. 
Внутри контейнера можно использовать команду ps, чтобы увидеть запущенные процессы. 
5. Проверка на наличие ошибок:
Если контейнер не запускается или ведет себя непредсказуемо, просмотрите логи (docker logs) и проверьте конфигурацию (docker-compose config или docker inspect). 
Используйте команду docker ps -a, чтобы убедиться, что контейнер не был остановлен по ошибке.

В конфигурации Docker Compose (если используется) можно настроить проверку работоспособности контейнера (healthcheck). 